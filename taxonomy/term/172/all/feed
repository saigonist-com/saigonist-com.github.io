<?xml version="1.0" encoding="utf-8" ?><rss version="2.0" xml:base="http://www.saigonist.com/taxonomy/term/172/all" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>hack</title>
    <link>http://www.saigonist.com/taxonomy/term/172/all</link>
    <description></description>
    <language>en</language>
          <item>
    <title>Fake Download Resume by Hacking TCP?</title>
    <link>http://www.saigonist.com/b/fake-download-resume-hacking-tcp</link>
    <description>&lt;p&gt;Just an idea. There are websites that allow resuming of partially downloaded files. But even if the browser or client (curl, &lt;span data-scayt_word=&quot;wget&quot; data-scaytid=&quot;1&quot;&gt;wget&lt;/span&gt;, etc.) supports resume if the server doesn&amp;#39;t support it then you&amp;#39;re SOL. Some websites disallow resume intentionally.&amp;nbsp;&lt;/p&gt;&lt;p&gt;But perhaps there&amp;#39;s a way to fake resume by telling the web server to send data that the client doesn&amp;#39;t actually receive. So if I&amp;#39;ve already downloaded 100 MB of a file, then I would tell the server to rapidly send the first 100 MB of the file again but actually ignore it until data after the first 100 MB is sent.&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;font-size:11px;&quot;&gt;&lt;code&gt;TCP? TCP (of TCP/IP which runs the internet) is a &amp;quot;transmission control protocol&amp;quot; on top of IP meaning it sets up a connection between two computers which have a reason to exchange data (like a web browser on my computer and a web server out there on the internet). Part of this protocol says how one side sends a broken up piece of data and knows it was definitely received. The sender will send out pieces of data until the receiver either says to slow down, or the sender guesses that it&amp;#39;s sending too fast for the receiver to receive. It&amp;#39;s up to the receiver to respond saying it has received a piece of data, or all the data up to a certain point, and signal to the sender that it can either transmit data faster or slower. &lt;/code&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;You can think of it as two sentries on each end of a bridge. Each sentry allows cars to cross the bridge in one direction but to avoid the bridge from backing up (or breaking under load) the other side sends a bike messenger across to say &amp;quot;X number of cars have crossed; send more faster&amp;quot; or &amp;quot;it seems that car license number 1073 never made it across; send that load again&amp;quot;.&lt;/p&gt;&lt;p&gt;But say we don&amp;#39;t care about the first 100 MB of cars crossing the bridge and making it to the other side, because we already received their payload earlier. &amp;nbsp;What we want to do is convince the sender to as many cars as it can as quickly as it can, causing a traffic jam which will cause cars to fall off the bridge. &amp;nbsp;But we will lie and say that all the cars made it across.&lt;/p&gt;&lt;p&gt;The TCP equivalent would be to increase the receive window much more than usual, then periodically send &lt;span data-scayt_word=&quot;ACK&quot; data-scaytid=&quot;2&quot;&gt;ACK&lt;/span&gt; acknowledgement packets with fake sequence numbers, numbers which are ahead of what we&amp;#39;ve really already received. &amp;nbsp;We guess what sequence number the sender has most recently sent out and tell them we have already received that packet so they can send more. &amp;nbsp;We still need to know how much actual data the sender has sent so that we can tell when we need to go back to normal at 100 MB.&lt;/p&gt;&lt;p&gt;Could this really work? If it did, it would require more than a change to a browser or client. &amp;nbsp;It would require hacking TCP itself, which is inside the operating system. &amp;nbsp;Of course, with Linux of &lt;span data-scayt_word=&quot;OpenBSD&quot; data-scaytid=&quot;3&quot;&gt;OpenBSD&lt;/span&gt;, it&amp;#39;s quite possible to hack the networking code yourself to compile your own custom kernel, perhaps even as a &lt;span data-scayt_word=&quot;reloadable&quot; data-scaytid=&quot;4&quot;&gt;reloadable&lt;/span&gt; kernel module. Then you would also need a custom client, like a modified curl/&lt;span data-scayt_word=&quot;wget&quot; data-scaytid=&quot;17&quot;&gt;wget&lt;/span&gt;, that signals to the OS that a certain TCP connection should &amp;quot;fake download&amp;quot; for a number of bytes, and then the client must resume appending to a file once the OS detects that downloading has surpassed that threshold.&lt;/p&gt;&lt;p&gt;I can&amp;#39;t be the only one who has thought of this, so let me know if this has actually been done before, or if not, why not?&lt;/p&gt;</description>
     <comments>http://www.saigonist.com/b/fake-download-resume-hacking-tcp#comments</comments>
 <category domain="http://www.saigonist.com/category/type/tech">Tech</category>
 <category domain="http://www.saigonist.com/category/tags/hack">hack</category>
 <category domain="http://www.saigonist.com/category/tags/tcpip">tcp/ip</category>
 <pubDate>Mon, 29 Aug 2011 17:51:55 +0000</pubDate>
 <dc:creator>tomo</dc:creator>
 <guid isPermaLink="false">251 at http://www.saigonist.com</guid>
  </item>
  </channel>
</rss>